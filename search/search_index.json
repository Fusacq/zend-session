{
    "docs": [
        {
            "location": "/",
            "text": "../../README.md",
            "title": "Home"
        },
        {
            "location": "/config/",
            "text": "Session Config\n\n\nzend-session comes with a standard set of config classes, allowing setting where\na cookie lives, session lifetime, and even configuration of ext/session when\nusing \nZend\\Session\\Config\\SessionConfig\n.\n\n\nStandard Config\n\n\nZend\\Session\\Config\\StandardConfig\n provides the base interface for\nconfiguring sessions when \nnot\n leveraging ext/session. This is utilized more\nfor specialized cases, such as when you might have session management done by\nanother system, or when testing.\n\n\nBasic Configuration Options\n\n\nThe following configuration options are defined by \nZend\\Session\\Config\\StandardConfig\n.\n\n\n\n\n\n\n\n\nOption\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncache_expire\n\n\ninteger\n\n\nSpecifies time-to-live for cached session pages in minutes.\n\n\n\n\n\n\ncookie_domain\n\n\nstring\n\n\nSpecifies the domain to set in the session cookie.\n\n\n\n\n\n\ncookie_httponly\n\n\nboolean\n\n\nMarks the cookie as accessible only through the HTTP protocol.\n\n\n\n\n\n\ncookie_lifetime\n\n\ninteger\n\n\nSpecifies the lifetime of the cookie in seconds which is sent to the browser.\n\n\n\n\n\n\ncookie_path\n\n\nstring\n\n\nSpecifies path to set in the session cookie.\n\n\n\n\n\n\ncookie_secure\n\n\nboolean\n\n\nSpecifies whether cookies should only be sent over secure connections.\n\n\n\n\n\n\nentropy_length\n\n\ninteger\n\n\nSpecifies the number of bytes which will be read from the file specified in entropy_file. Removed in PHP 7.1.0.\n\n\n\n\n\n\nentropy_file\n\n\nstring\n\n\nDefines a path to an external resource (file) which will be used as an additional entropy. Removed in PHP 7.1.0.\n\n\n\n\n\n\ngc_maxlifetime\n\n\ninteger\n\n\nSpecifies the number of seconds after which data will be seen as \u2018garbage\u2019.\n\n\n\n\n\n\ngc_divisor\n\n\ninteger\n\n\nDefines the probability that the gc process is started on every session initialization.\n\n\n\n\n\n\ngc_probability\n\n\ninteger\n\n\nDefines the probability that the gc process is started on every session initialization.\n\n\n\n\n\n\nhash_function\n\n\ninteger\n\n\nDefines which built-in hash algorithm is used. Removed in PHP 7.1.0.\n\n\n\n\n\n\nhash_bits_per_character\n\n\ninteger\n\n\nDefines how many bits are stored in each character when converting the binary hash data. Removed in PHP 7.1.0.\n\n\n\n\n\n\nname\n\n\nstring\n\n\nSpecifies the name of the session which is used as cookie name.\n\n\n\n\n\n\nremember_me_seconds\n\n\ninteger\n\n\nSpecifies how long to remember the session before clearing data.\n\n\n\n\n\n\nsave_path\n\n\nstring\n\n\nDefines the argument which is passed to the save handler.\n\n\n\n\n\n\nuse_cookies\n\n\nboolean\n\n\nSpecifies whether the module will use cookies to store the session id.\n\n\n\n\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Session\\Config\\StandardConfig;\nuse Zend\\Session\\SessionManager;\n\n$config = new StandardConfig();\n$config->setOptions([\n    'remember_me_seconds' => 1800,\n    'name'                => 'zf2',\n]);\n$manager = new SessionManager($config);\n\n\n\nSession Config\n\n\nZend\\Session\\Config\\SessionConfig\n provides an interface for configuring\nsessions that leverage PHP's ext/session. Most configuration options configure\neither the \nZend\\Session\\Storage\n OR configure ext/session directly.\n\n\nBasic Configuration Options\n\n\nThe following configuration options are defined by \nZend\\Session\\Config\\SessionConfig\n;\nnote that it inherits all configuration from\n\nZend\\Session\\Config\\StandardConfig\n.\n\n\n\n\n\n\n\n\nOption\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncache_limiter\n\n\nstring\n\n\nSpecifies the cache control method used for session pages.\n\n\n\n\n\n\nhash_function\n\n\nstring\n\n\nAllows you to specify the hash algorithm used to generate the session IDs.\n\n\n\n\n\n\nphp_save_handler\n\n\nstring\n\n\nDefines the name of a PHP save_handler embedded into PHP.\n\n\n\n\n\n\nserialize_handler\n\n\nstring\n\n\nDefines the name of the handler which is used to serialize/deserialize data.\n\n\n\n\n\n\nurl_rewriter_tags\n\n\nstring\n\n\nSpecifies which HTML tags are rewritten to include session id if transparent sid enabled.\n\n\n\n\n\n\nuse_trans_sid\n\n\nboolean\n\n\nWhether transparent sid support is enabled or not.\n\n\n\n\n\n\n\n\nBasic Usage\n\n\nuse Zend\\Session\\Config\\SessionConfig;\nuse Zend\\Session\\SessionManager;\n\n$config = new SessionConfig();\n$config->setOptions([\n    'phpSaveHandler' => 'redis',\n    'savePath' => 'tcp://127.0.0.1:6379?weight=1&timeout=1',\n]);\n$manager = new SessionManager($config);\n\n\n\nService Manager Factory\n\n\nzend-session ships with a \nzend-servicemanager\n\nfactory which reads configuration data from the application configuration and\ninjects a corresponding instance of \nZend\\Session\\Config\\SessionConfig\n into the\nsession manager automatically.\n\n\nTo use this factory, you first need to register it with the service manager by adding the\nappropriate factory definition:\n\n\n'service_manager' => [\n    'factories' => [\n        'Zend\\Session\\Config\\ConfigInterface' => 'Zend\\Session\\Service\\SessionConfigFactory',\n    ],\n],\n\n\n\n\n\nAutomated factory registration\n\n\nStarting with zend-mvc v3, if you are using the \ncomponent installer\n\nin your application, the above registration will be made automatically for\nyou when you install zend-session.\n\n\n\n\nThen place your application's session configuration in the root-level\nconfiguration key \nsession_config\n:\n\n\n'session_config' => [\n    'phpSaveHandler' => 'redis',\n    'savePath' => 'tcp://127.0.0.1:6379?weight=1&timeout=1',\n],\n\n\n\nAny of the configuration options defined for \nSessionConfig\n can be used\nthere, as well as the following factory-specific configuration options:\n\n\n\n\n\n\n\n\nOption\n\n\nData Type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconfig_class\n\n\nstring\n\n\nName of the class to use as the configuration container (Defaults to \nZend\\Session\\Config\\SessionConfig\n)\n\n\n\n\n\n\n\n\nCustom Configuration\n\n\nIn the event that you prefer to create your own session configuration; you\n\nmust\n implement \nZend\\Session\\Config\\ConfigInterface\n which contains the basic\ninterface for items needed when implementing a session. This includes cookie\nconfiguration, lifetime, session name, save path, and an interface for getting\nand setting options.",
            "title": "Session Config"
        },
        {
            "location": "/config/#session-config",
            "text": "zend-session comes with a standard set of config classes, allowing setting where\na cookie lives, session lifetime, and even configuration of ext/session when\nusing  Zend\\Session\\Config\\SessionConfig .",
            "title": "Session Config"
        },
        {
            "location": "/config/#standard-config",
            "text": "Zend\\Session\\Config\\StandardConfig  provides the base interface for\nconfiguring sessions when  not  leveraging ext/session. This is utilized more\nfor specialized cases, such as when you might have session management done by\nanother system, or when testing.",
            "title": "Standard Config"
        },
        {
            "location": "/config/#basic-configuration-options",
            "text": "The following configuration options are defined by  Zend\\Session\\Config\\StandardConfig .     Option  Data Type  Description      cache_expire  integer  Specifies time-to-live for cached session pages in minutes.    cookie_domain  string  Specifies the domain to set in the session cookie.    cookie_httponly  boolean  Marks the cookie as accessible only through the HTTP protocol.    cookie_lifetime  integer  Specifies the lifetime of the cookie in seconds which is sent to the browser.    cookie_path  string  Specifies path to set in the session cookie.    cookie_secure  boolean  Specifies whether cookies should only be sent over secure connections.    entropy_length  integer  Specifies the number of bytes which will be read from the file specified in entropy_file. Removed in PHP 7.1.0.    entropy_file  string  Defines a path to an external resource (file) which will be used as an additional entropy. Removed in PHP 7.1.0.    gc_maxlifetime  integer  Specifies the number of seconds after which data will be seen as \u2018garbage\u2019.    gc_divisor  integer  Defines the probability that the gc process is started on every session initialization.    gc_probability  integer  Defines the probability that the gc process is started on every session initialization.    hash_function  integer  Defines which built-in hash algorithm is used. Removed in PHP 7.1.0.    hash_bits_per_character  integer  Defines how many bits are stored in each character when converting the binary hash data. Removed in PHP 7.1.0.    name  string  Specifies the name of the session which is used as cookie name.    remember_me_seconds  integer  Specifies how long to remember the session before clearing data.    save_path  string  Defines the argument which is passed to the save handler.    use_cookies  boolean  Specifies whether the module will use cookies to store the session id.",
            "title": "Basic Configuration Options"
        },
        {
            "location": "/config/#basic-usage",
            "text": "use Zend\\Session\\Config\\StandardConfig;\nuse Zend\\Session\\SessionManager;\n\n$config = new StandardConfig();\n$config->setOptions([\n    'remember_me_seconds' => 1800,\n    'name'                => 'zf2',\n]);\n$manager = new SessionManager($config);",
            "title": "Basic Usage"
        },
        {
            "location": "/config/#session-config_1",
            "text": "Zend\\Session\\Config\\SessionConfig  provides an interface for configuring\nsessions that leverage PHP's ext/session. Most configuration options configure\neither the  Zend\\Session\\Storage  OR configure ext/session directly.",
            "title": "Session Config"
        },
        {
            "location": "/config/#basic-configuration-options_1",
            "text": "The following configuration options are defined by  Zend\\Session\\Config\\SessionConfig ;\nnote that it inherits all configuration from Zend\\Session\\Config\\StandardConfig .     Option  Data Type  Description      cache_limiter  string  Specifies the cache control method used for session pages.    hash_function  string  Allows you to specify the hash algorithm used to generate the session IDs.    php_save_handler  string  Defines the name of a PHP save_handler embedded into PHP.    serialize_handler  string  Defines the name of the handler which is used to serialize/deserialize data.    url_rewriter_tags  string  Specifies which HTML tags are rewritten to include session id if transparent sid enabled.    use_trans_sid  boolean  Whether transparent sid support is enabled or not.",
            "title": "Basic Configuration Options"
        },
        {
            "location": "/config/#basic-usage_1",
            "text": "use Zend\\Session\\Config\\SessionConfig;\nuse Zend\\Session\\SessionManager;\n\n$config = new SessionConfig();\n$config->setOptions([\n    'phpSaveHandler' => 'redis',\n    'savePath' => 'tcp://127.0.0.1:6379?weight=1&timeout=1',\n]);\n$manager = new SessionManager($config);",
            "title": "Basic Usage"
        },
        {
            "location": "/config/#service-manager-factory",
            "text": "zend-session ships with a  zend-servicemanager \nfactory which reads configuration data from the application configuration and\ninjects a corresponding instance of  Zend\\Session\\Config\\SessionConfig  into the\nsession manager automatically.  To use this factory, you first need to register it with the service manager by adding the\nappropriate factory definition:  'service_manager' => [\n    'factories' => [\n        'Zend\\Session\\Config\\ConfigInterface' => 'Zend\\Session\\Service\\SessionConfigFactory',\n    ],\n],",
            "title": "Service Manager Factory"
        },
        {
            "location": "/config/#automated-factory-registration",
            "text": "Starting with zend-mvc v3, if you are using the  component installer \nin your application, the above registration will be made automatically for\nyou when you install zend-session.   Then place your application's session configuration in the root-level\nconfiguration key  session_config :  'session_config' => [\n    'phpSaveHandler' => 'redis',\n    'savePath' => 'tcp://127.0.0.1:6379?weight=1&timeout=1',\n],  Any of the configuration options defined for  SessionConfig  can be used\nthere, as well as the following factory-specific configuration options:     Option  Data Type  Description      config_class  string  Name of the class to use as the configuration container (Defaults to  Zend\\Session\\Config\\SessionConfig )",
            "title": "Automated factory registration"
        },
        {
            "location": "/config/#custom-configuration",
            "text": "In the event that you prefer to create your own session configuration; you must  implement  Zend\\Session\\Config\\ConfigInterface  which contains the basic\ninterface for items needed when implementing a session. This includes cookie\nconfiguration, lifetime, session name, save path, and an interface for getting\nand setting options.",
            "title": "Custom Configuration"
        },
        {
            "location": "/container/",
            "text": "Session Container\n\n\nZend\\Session\\Container\n instances provide the primary API for manipulating\nsession data in zend-session. Containers are used to segregate all session\ndata, although a default namespace exists for those who only want one namespace\nfor all their session data.\n\n\nEach instance of \nZend\\Session\\Container\n corresponds to an entry of the\n\nZend\\Session\\Storage\n, where the namespace is used as the key.\n\nZend\\Session\\Container\n itself is an instance of an \nArrayObject\n.\n\n\nBasic Usage\n\n\nuse Zend\\Session\\Container;\n\n$container = new Container('namespace');\n$container->item = 'foo';\n\n\n\nSetting the Default Session Manager\n\n\nIn the event you are using multiple session managers or prefer to be explicit,\nthe default session manager that is utilized can be explicitly set.\n\n\nuse Zend\\Session\\Container;\nuse Zend\\Session\\SessionManager;\n\n$manager = new SessionManager();\nContainer::setDefaultManager($manager);",
            "title": "Session Container"
        },
        {
            "location": "/container/#session-container",
            "text": "Zend\\Session\\Container  instances provide the primary API for manipulating\nsession data in zend-session. Containers are used to segregate all session\ndata, although a default namespace exists for those who only want one namespace\nfor all their session data.  Each instance of  Zend\\Session\\Container  corresponds to an entry of the Zend\\Session\\Storage , where the namespace is used as the key. Zend\\Session\\Container  itself is an instance of an  ArrayObject .",
            "title": "Session Container"
        },
        {
            "location": "/container/#basic-usage",
            "text": "use Zend\\Session\\Container;\n\n$container = new Container('namespace');\n$container->item = 'foo';",
            "title": "Basic Usage"
        },
        {
            "location": "/container/#setting-the-default-session-manager",
            "text": "In the event you are using multiple session managers or prefer to be explicit,\nthe default session manager that is utilized can be explicitly set.  use Zend\\Session\\Container;\nuse Zend\\Session\\SessionManager;\n\n$manager = new SessionManager();\nContainer::setDefaultManager($manager);",
            "title": "Setting the Default Session Manager"
        },
        {
            "location": "/manager/",
            "text": "Session Manager\n\n\nThe session manager, \nZend\\Session\\SessionManager\n, is the class responsible for\nall aspects of session management. It initializes configuration, storage, and\nsave handlers.  Additionally the session manager can be injected into the\nsession container to provide a wrapper or namespace around your session data.\n\n\nThe session manager is responsible for starting a session, testing if a session\nexists, writing to the session, regenerating the session identifier, setting the\nsession time-to-live, and destroying the session. The session manager can\nvalidate sessions from a validator chain to ensure that the session data is\ncorrect.\n\n\nInitializing the Session Manager\n\n\nGenerally speaking, you will always want to initialize the session manager and\nensure that your application was responsible for its initialization; this puts\nin place a simple solution to prevent against session fixation. Generally you\nwill setup configuration and then inside of an application module bootstrap the\nsession manager.\n\n\nAdditionally you will likely want to supply validators to prevent against\nsession hijacking.\n\n\nThe following illustrates how you may configure the session manager by setting\noptions in your local or global config:\n\n\nuse Zend\\Session;\n\nreturn [\n    'session_manager' => [\n        'config' => [\n            'class' => Session\\Config\\SessionConfig::class,\n            'options' => [\n                'name' => 'myapp',\n            ],\n        ],\n        'storage' => Session\\Storage\\SessionArrayStorage::class,\n        'validators' => [\n            Session\\Validator\\RemoteAddr::class,\n            Session\\Validator\\HttpUserAgent::class,\n        ],\n    ],\n];\n\n\n\nThe following illustrates how you might utilize the above configuration to\ncreate the session manager:\n\n\nuse Zend\\Session\\SessionManager;\nuse Zend\\Session\\Config\\SessionConfig;\nuse Zend\\Session\\Container;\nuse Zend\\Session\\Validator;\n\nclass Module\n{\n    public function onBootstrap($e)\n    {\n        $eventManager        = $e->getApplication()->getEventManager();\n        $moduleRouteListener = new ModuleRouteListener();\n        $moduleRouteListener->attach($eventManager);\n        $this->bootstrapSession($e);\n    }\n\n    public function bootstrapSession($e)\n    {\n        $session = $e->getApplication()\n            ->getServiceManager()\n            ->get(SessionManager::class);\n        $session->start();\n\n        $container = new Container('initialized');\n\n        if (isset($container->init)) {\n            return;\n        }\n\n        $serviceManager = $e->getApplication()->getServiceManager();\n        $request        = $serviceManager->get('Request');\n\n        $session->regenerateId(true);\n        $container->init          = 1;\n        $container->remoteAddr    = $request->getServer()->get('REMOTE_ADDR');\n        $container->httpUserAgent = $request->getServer()->get('HTTP_USER_AGENT');\n\n        $config = $serviceManager->get('Config');\n        if (! isset($config['session'])) {\n            return;\n        }\n\n        $sessionConfig = $config['session'];\n\n        if (! isset($sessionConfig['validators'])) {\n            return;\n        }\n\n        $chain   = $session->getValidatorChain();\n\n        foreach ($sessionConfig['validators'] as $validator) {\n            switch ($validator) {\n            case Validator\\HttpUserAgent::class:\n                    $validator = new $validator($container->httpUserAgent);\n                    break;\n                    case Validator\\RemoteAddr::class:\n                    $validator  = new $validator($container->remoteAddr);\n                    break;\n                default:\n                    $validator = new $validator();\n            }\n\n            $chain->attach('session.validate', array($validator, 'isValid'));\n        }\n    }\n\n    public function getServiceConfig()\n    {\n        return [\n            'factories' => [\n                SessionManager::class => function ($container) {\n                    $config = $container->get('config');\n                    if (! isset($config['session'])) {\n                        $sessionManager = new SessionManager();\n                        Container::setDefaultManager($sessionManager);\n                        return $sessionManager;\n                    }\n\n                    $session = $config['session'];\n\n                    $sessionConfig = null;\n                    if (isset($session['config'])) {\n                        $class = isset($session['config']['class'])\n                            ?  $session['config']['class']\n                            : SessionConfig::class;\n\n                        $options = isset($session['config']['options'])\n                            ?  $session['config']['options']\n                            : [];\n\n                        $sessionConfig = new $class();\n                        $sessionConfig->setOptions($options);\n                    }\n\n                    $sessionStorage = null;\n                    if (isset($session['storage'])) {\n                        $class = $session['storage'];\n                        $sessionStorage = new $class();\n                    }\n\n                    $sessionSaveHandler = null;\n                    if (isset($session['save_handler'])) {\n                        // class should be fetched from service manager\n                        // since it will require constructor arguments\n                        $sessionSaveHandler = $container->get($session['save_handler']);\n                    }\n\n                    $sessionManager = new SessionManager(\n                        $sessionConfig,\n                        $sessionStorage,\n                        $sessionSaveHandler\n                    );\n\n                    Container::setDefaultManager($sessionManager);\n                    return $sessionManager;\n                },\n            ],\n        ];\n    }\n}\n\n\n\nWhen you create a new \nZend\\Session\\Container\n (see\n\nSession Container\n page) in a controller, for example, it will\nuse the session configured above.",
            "title": "Session Manager"
        },
        {
            "location": "/manager/#session-manager",
            "text": "The session manager,  Zend\\Session\\SessionManager , is the class responsible for\nall aspects of session management. It initializes configuration, storage, and\nsave handlers.  Additionally the session manager can be injected into the\nsession container to provide a wrapper or namespace around your session data.  The session manager is responsible for starting a session, testing if a session\nexists, writing to the session, regenerating the session identifier, setting the\nsession time-to-live, and destroying the session. The session manager can\nvalidate sessions from a validator chain to ensure that the session data is\ncorrect.",
            "title": "Session Manager"
        },
        {
            "location": "/manager/#initializing-the-session-manager",
            "text": "Generally speaking, you will always want to initialize the session manager and\nensure that your application was responsible for its initialization; this puts\nin place a simple solution to prevent against session fixation. Generally you\nwill setup configuration and then inside of an application module bootstrap the\nsession manager.  Additionally you will likely want to supply validators to prevent against\nsession hijacking.  The following illustrates how you may configure the session manager by setting\noptions in your local or global config:  use Zend\\Session;\n\nreturn [\n    'session_manager' => [\n        'config' => [\n            'class' => Session\\Config\\SessionConfig::class,\n            'options' => [\n                'name' => 'myapp',\n            ],\n        ],\n        'storage' => Session\\Storage\\SessionArrayStorage::class,\n        'validators' => [\n            Session\\Validator\\RemoteAddr::class,\n            Session\\Validator\\HttpUserAgent::class,\n        ],\n    ],\n];  The following illustrates how you might utilize the above configuration to\ncreate the session manager:  use Zend\\Session\\SessionManager;\nuse Zend\\Session\\Config\\SessionConfig;\nuse Zend\\Session\\Container;\nuse Zend\\Session\\Validator;\n\nclass Module\n{\n    public function onBootstrap($e)\n    {\n        $eventManager        = $e->getApplication()->getEventManager();\n        $moduleRouteListener = new ModuleRouteListener();\n        $moduleRouteListener->attach($eventManager);\n        $this->bootstrapSession($e);\n    }\n\n    public function bootstrapSession($e)\n    {\n        $session = $e->getApplication()\n            ->getServiceManager()\n            ->get(SessionManager::class);\n        $session->start();\n\n        $container = new Container('initialized');\n\n        if (isset($container->init)) {\n            return;\n        }\n\n        $serviceManager = $e->getApplication()->getServiceManager();\n        $request        = $serviceManager->get('Request');\n\n        $session->regenerateId(true);\n        $container->init          = 1;\n        $container->remoteAddr    = $request->getServer()->get('REMOTE_ADDR');\n        $container->httpUserAgent = $request->getServer()->get('HTTP_USER_AGENT');\n\n        $config = $serviceManager->get('Config');\n        if (! isset($config['session'])) {\n            return;\n        }\n\n        $sessionConfig = $config['session'];\n\n        if (! isset($sessionConfig['validators'])) {\n            return;\n        }\n\n        $chain   = $session->getValidatorChain();\n\n        foreach ($sessionConfig['validators'] as $validator) {\n            switch ($validator) {\n            case Validator\\HttpUserAgent::class:\n                    $validator = new $validator($container->httpUserAgent);\n                    break;\n                    case Validator\\RemoteAddr::class:\n                    $validator  = new $validator($container->remoteAddr);\n                    break;\n                default:\n                    $validator = new $validator();\n            }\n\n            $chain->attach('session.validate', array($validator, 'isValid'));\n        }\n    }\n\n    public function getServiceConfig()\n    {\n        return [\n            'factories' => [\n                SessionManager::class => function ($container) {\n                    $config = $container->get('config');\n                    if (! isset($config['session'])) {\n                        $sessionManager = new SessionManager();\n                        Container::setDefaultManager($sessionManager);\n                        return $sessionManager;\n                    }\n\n                    $session = $config['session'];\n\n                    $sessionConfig = null;\n                    if (isset($session['config'])) {\n                        $class = isset($session['config']['class'])\n                            ?  $session['config']['class']\n                            : SessionConfig::class;\n\n                        $options = isset($session['config']['options'])\n                            ?  $session['config']['options']\n                            : [];\n\n                        $sessionConfig = new $class();\n                        $sessionConfig->setOptions($options);\n                    }\n\n                    $sessionStorage = null;\n                    if (isset($session['storage'])) {\n                        $class = $session['storage'];\n                        $sessionStorage = new $class();\n                    }\n\n                    $sessionSaveHandler = null;\n                    if (isset($session['save_handler'])) {\n                        // class should be fetched from service manager\n                        // since it will require constructor arguments\n                        $sessionSaveHandler = $container->get($session['save_handler']);\n                    }\n\n                    $sessionManager = new SessionManager(\n                        $sessionConfig,\n                        $sessionStorage,\n                        $sessionSaveHandler\n                    );\n\n                    Container::setDefaultManager($sessionManager);\n                    return $sessionManager;\n                },\n            ],\n        ];\n    }\n}  When you create a new  Zend\\Session\\Container  (see Session Container  page) in a controller, for example, it will\nuse the session configured above.",
            "title": "Initializing the Session Manager"
        },
        {
            "location": "/save-handler/",
            "text": "Session Save Handlers\n\n\nzend-session comes with a set of save handler classes.  Save handlers themselves\nare decoupled from PHP's save handler functions and are only implemented as a\nPHP save handler when utilized in conjunction with\n\nZend\\Session\\SessionManager\n.\n\n\nCache\n\n\nZend\\Session\\SaveHandler\\Cache\n allows you to provide an instance of\n\nZend\\Cache\\Storage\\Adapter\\AdapterInterface\n to be utilized as a session save\nhandler. Generally if you are utilizing the \nCache\n save handler; you are likely\nusing products such as memcached.\n\n\nBasic usage\n\n\nA basic example is one like the following:\n\n\nuse Zend\\Cache\\StorageFactory;\nuse Zend\\Session\\SaveHandler\\Cache;\nuse Zend\\Session\\SessionManager;\n\n$cache = StorageFactory::factory([\n    'adapter' => [\n       'name' => 'memcached',\n       'options' => [\n           'server' => '127.0.0.1',\n       ],\n    ],\n]);\n\n$saveHandler = new Cache($cache);\n$manager = new SessionManager();\n$manager->setSaveHandler($saveHandler);\n\n\n\nDbTableGateway\n\n\nZend\\Session\\SaveHandler\\DbTableGateway\n allows you to utilize\n\nZend\\Db\\TableGateway\\TableGatewayInterface\n implementations as a session save\nhandler. Setup of a \nDbTableGateway\n save handler requires an instance of\n\nZend\\Db\\TableGateway\\TableGatewayInterface\n and an instance of\n\nZend\\Session\\SaveHandler\\DbTableGatewayOptions\n. In the most basic setup, a\n\nTableGateway\n object and using the defaults of the \nDbTableGatewayOptions\n will\nprovide you with what you need.\n\n\nCreating the database table\n\n\nCREATE TABLE `session` (\n    `id` char(32),\n    `name` char(32),\n    `modified` int,\n    `lifetime` int,\n    `data` text,\n     PRIMARY KEY (`id`, `name`)\n);\n\n\n\nBasic usage\n\n\nuse Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\Session\\SaveHandler\\DbTableGateway;\nuse Zend\\Session\\SaveHandler\\DbTableGatewayOptions;\nuse Zend\\Session\\SessionManager;\n\n$tableGateway = new TableGateway('session', $adapter);\n$saveHandler  = new DbTableGateway($tableGateway, new DbTableGatewayOptions());\n$manager      = new SessionManager();\n$manager->setSaveHandler($saveHandler);\n\n\n\nMongoDB\n\n\nZend\\Session\\SaveHandler\\MongoDB\n allows you to provide a MongoDB collection to\nbe utilized as a session save handler. You provide the options in the\n\nZend\\Session\\SaveHandler\\MongoDBOptions\n class. You must install the\n\nmongodb PHP extensions\n and the\n\nMongoDB PHP library\n.\n\n\nBasic Usage\n\n\nuse MongoDB\\Client;\nuse Zend\\Session\\SaveHandler\\MongoDB;\nuse Zend\\Session\\SaveHandler\\MongoDBOptions;\nuse Zend\\Session\\SessionManager;\n\n$mongoClient = new Client();\n$options = new MongoDBOptions([\n    'database'   => 'myapp',\n    'collection' => 'sessions',\n]);\n$saveHandler = new MongoDB($mongoClient, $options);\n$manager     = new SessionManager();\n$manager->setSaveHandler($saveHandler);\n\n\n\nCustom Save Handlers\n\n\nThere may be cases where you want to create a save handler.  Creating a custom\nsave handler is much like creating a custom PHP save handler, with minor\ndifferences. All zend-session-compatible save handlers \nmust\n implement\n\nZend\\Session\\SaveHandler\\SaveHandlerInterface\n.  Additionally, if your save\nhandler has configurable functionality, you will also need to create an options\nclass.",
            "title": "Session Save Handlers"
        },
        {
            "location": "/save-handler/#session-save-handlers",
            "text": "zend-session comes with a set of save handler classes.  Save handlers themselves\nare decoupled from PHP's save handler functions and are only implemented as a\nPHP save handler when utilized in conjunction with Zend\\Session\\SessionManager .",
            "title": "Session Save Handlers"
        },
        {
            "location": "/save-handler/#cache",
            "text": "Zend\\Session\\SaveHandler\\Cache  allows you to provide an instance of Zend\\Cache\\Storage\\Adapter\\AdapterInterface  to be utilized as a session save\nhandler. Generally if you are utilizing the  Cache  save handler; you are likely\nusing products such as memcached.",
            "title": "Cache"
        },
        {
            "location": "/save-handler/#basic-usage",
            "text": "A basic example is one like the following:  use Zend\\Cache\\StorageFactory;\nuse Zend\\Session\\SaveHandler\\Cache;\nuse Zend\\Session\\SessionManager;\n\n$cache = StorageFactory::factory([\n    'adapter' => [\n       'name' => 'memcached',\n       'options' => [\n           'server' => '127.0.0.1',\n       ],\n    ],\n]);\n\n$saveHandler = new Cache($cache);\n$manager = new SessionManager();\n$manager->setSaveHandler($saveHandler);",
            "title": "Basic usage"
        },
        {
            "location": "/save-handler/#dbtablegateway",
            "text": "Zend\\Session\\SaveHandler\\DbTableGateway  allows you to utilize Zend\\Db\\TableGateway\\TableGatewayInterface  implementations as a session save\nhandler. Setup of a  DbTableGateway  save handler requires an instance of Zend\\Db\\TableGateway\\TableGatewayInterface  and an instance of Zend\\Session\\SaveHandler\\DbTableGatewayOptions . In the most basic setup, a TableGateway  object and using the defaults of the  DbTableGatewayOptions  will\nprovide you with what you need.",
            "title": "DbTableGateway"
        },
        {
            "location": "/save-handler/#creating-the-database-table",
            "text": "CREATE TABLE `session` (\n    `id` char(32),\n    `name` char(32),\n    `modified` int,\n    `lifetime` int,\n    `data` text,\n     PRIMARY KEY (`id`, `name`)\n);",
            "title": "Creating the database table"
        },
        {
            "location": "/save-handler/#basic-usage_1",
            "text": "use Zend\\Db\\TableGateway\\TableGateway;\nuse Zend\\Session\\SaveHandler\\DbTableGateway;\nuse Zend\\Session\\SaveHandler\\DbTableGatewayOptions;\nuse Zend\\Session\\SessionManager;\n\n$tableGateway = new TableGateway('session', $adapter);\n$saveHandler  = new DbTableGateway($tableGateway, new DbTableGatewayOptions());\n$manager      = new SessionManager();\n$manager->setSaveHandler($saveHandler);",
            "title": "Basic usage"
        },
        {
            "location": "/save-handler/#mongodb",
            "text": "Zend\\Session\\SaveHandler\\MongoDB  allows you to provide a MongoDB collection to\nbe utilized as a session save handler. You provide the options in the Zend\\Session\\SaveHandler\\MongoDBOptions  class. You must install the mongodb PHP extensions  and the MongoDB PHP library .",
            "title": "MongoDB"
        },
        {
            "location": "/save-handler/#basic-usage_2",
            "text": "use MongoDB\\Client;\nuse Zend\\Session\\SaveHandler\\MongoDB;\nuse Zend\\Session\\SaveHandler\\MongoDBOptions;\nuse Zend\\Session\\SessionManager;\n\n$mongoClient = new Client();\n$options = new MongoDBOptions([\n    'database'   => 'myapp',\n    'collection' => 'sessions',\n]);\n$saveHandler = new MongoDB($mongoClient, $options);\n$manager     = new SessionManager();\n$manager->setSaveHandler($saveHandler);",
            "title": "Basic Usage"
        },
        {
            "location": "/save-handler/#custom-save-handlers",
            "text": "There may be cases where you want to create a save handler.  Creating a custom\nsave handler is much like creating a custom PHP save handler, with minor\ndifferences. All zend-session-compatible save handlers  must  implement Zend\\Session\\SaveHandler\\SaveHandlerInterface .  Additionally, if your save\nhandler has configurable functionality, you will also need to create an options\nclass.",
            "title": "Custom Save Handlers"
        },
        {
            "location": "/storage/",
            "text": "Session Storage\n\n\nzend-session comes with a standard set of storage handlers. Storage handlers are\nthe intermediary between when the session starts and when the session writes and\ncloses.  The default session storage is\n\nZend\\Session\\Storage\\SessionArrayStorage\n.\n\n\nArray Storage\n\n\nZend\\Session\\Storage\\ArrayStorage\n provides a facility to store all information\nin an \nArrayObject\n. This storage method is likely incompatible with 3rd party\nlibraries and all properties will be inaccessible through the \n$_SESSION\n\nsuperglobal. Additionally \nArrayStorage\n will not automatically repopulate the\nstorage container in the case of each new request and would have to manually be\nre-populated.\n\n\nBasic Usage\n\n\nuse Zend\\Session\\Storage\\ArrayStorage;\nuse Zend\\Session\\SessionManager;\n\n$populateStorage = ['foo' => 'bar'];\n$storage         = new ArrayStorage($populateStorage);\n$manager         = new SessionManager();\n$manager->setStorage($storage);\n\n\n\nSession Storage\n\n\nZend\\Session\\Storage\\SessionStorage\n replaces \n$_SESSION,\n providing a facility\nto store all information in an \nArrayObject\n. This means that it may not be\ncompatible with 3rd party libraries, although information stored in the\n\n$_SESSION\n superglobal should be available in other scopes.\n\n\nBasic Usage\n\n\nuse Zend\\Session\\Storage\\SessionStorage;\nuse Zend\\Session\\SessionManager;\n\n$manager = new SessionManager();\n$manager->setStorage(new SessionStorage());\n\n\n\nSession Array Storage\n\n\nZend\\Session\\Storage\\SessionArrayStorage\n provides a facility to store all\ninformation directly in the \n$_SESSION\n superglobal. This storage class provides\nthe most compatibility with 3rd party libraries and allows for directly storing\ninformation into \n$_SESSION\n.\n\n\nBasic Usage\n\n\nuse Zend\\Session\\Storage\\SessionArrayStorage;\nuse Zend\\Session\\SessionManager;\n\n$manager = new SessionManager();\n$manager->setStorage(new SessionArrayStorage());\n\n\n\nCustom Storage\n\n\nTo create a custom storage container, you \nmust\n implement\n\nZend\\Session\\Storage\\StorageInterface\n. This interface extends each of\n\nArrayAccess\n, \nTraversable\n, \nSerializable\n, and \nCountable\n, and it is in the\nmethods those define that the majority of implementation occurs. The following\nmethods must also be implemented:\n\n\npublic function getRequestAccessTime() : int;\n\npublic function lock(int|string $key = null) : void;\npublic function isLocked(int|string $key = null) : bool;\npublic function unlock(int|string $key = null) : void;\n\npublic function markImmutable() : void;\npublic function isImmutable() : bool;\n\npublic function setMetadata(string $key, mixed $value, bool $overwriteArray = false) : void;\npublic function getMetadata(string $key = null) : mixed;\n\npublic function clear(inst|string $key = null) : void;\n\npublic function fromArray(array $array) : void;\npublic function toArray(bool $metaData = false) : array;",
            "title": "Session Storage"
        },
        {
            "location": "/storage/#session-storage",
            "text": "zend-session comes with a standard set of storage handlers. Storage handlers are\nthe intermediary between when the session starts and when the session writes and\ncloses.  The default session storage is Zend\\Session\\Storage\\SessionArrayStorage .",
            "title": "Session Storage"
        },
        {
            "location": "/storage/#array-storage",
            "text": "Zend\\Session\\Storage\\ArrayStorage  provides a facility to store all information\nin an  ArrayObject . This storage method is likely incompatible with 3rd party\nlibraries and all properties will be inaccessible through the  $_SESSION \nsuperglobal. Additionally  ArrayStorage  will not automatically repopulate the\nstorage container in the case of each new request and would have to manually be\nre-populated.",
            "title": "Array Storage"
        },
        {
            "location": "/storage/#basic-usage",
            "text": "use Zend\\Session\\Storage\\ArrayStorage;\nuse Zend\\Session\\SessionManager;\n\n$populateStorage = ['foo' => 'bar'];\n$storage         = new ArrayStorage($populateStorage);\n$manager         = new SessionManager();\n$manager->setStorage($storage);",
            "title": "Basic Usage"
        },
        {
            "location": "/storage/#session-storage_1",
            "text": "Zend\\Session\\Storage\\SessionStorage  replaces  $_SESSION,  providing a facility\nto store all information in an  ArrayObject . This means that it may not be\ncompatible with 3rd party libraries, although information stored in the $_SESSION  superglobal should be available in other scopes.",
            "title": "Session Storage"
        },
        {
            "location": "/storage/#basic-usage_1",
            "text": "use Zend\\Session\\Storage\\SessionStorage;\nuse Zend\\Session\\SessionManager;\n\n$manager = new SessionManager();\n$manager->setStorage(new SessionStorage());",
            "title": "Basic Usage"
        },
        {
            "location": "/storage/#session-array-storage",
            "text": "Zend\\Session\\Storage\\SessionArrayStorage  provides a facility to store all\ninformation directly in the  $_SESSION  superglobal. This storage class provides\nthe most compatibility with 3rd party libraries and allows for directly storing\ninformation into  $_SESSION .",
            "title": "Session Array Storage"
        },
        {
            "location": "/storage/#basic-usage_2",
            "text": "use Zend\\Session\\Storage\\SessionArrayStorage;\nuse Zend\\Session\\SessionManager;\n\n$manager = new SessionManager();\n$manager->setStorage(new SessionArrayStorage());",
            "title": "Basic Usage"
        },
        {
            "location": "/storage/#custom-storage",
            "text": "To create a custom storage container, you  must  implement Zend\\Session\\Storage\\StorageInterface . This interface extends each of ArrayAccess ,  Traversable ,  Serializable , and  Countable , and it is in the\nmethods those define that the majority of implementation occurs. The following\nmethods must also be implemented:  public function getRequestAccessTime() : int;\n\npublic function lock(int|string $key = null) : void;\npublic function isLocked(int|string $key = null) : bool;\npublic function unlock(int|string $key = null) : void;\n\npublic function markImmutable() : void;\npublic function isImmutable() : bool;\n\npublic function setMetadata(string $key, mixed $value, bool $overwriteArray = false) : void;\npublic function getMetadata(string $key = null) : mixed;\n\npublic function clear(inst|string $key = null) : void;\n\npublic function fromArray(array $array) : void;\npublic function toArray(bool $metaData = false) : array;",
            "title": "Custom Storage"
        },
        {
            "location": "/validator/",
            "text": "Session Validators\n\n\nSession validators provide protections against session hijacking.\n\n\nHttp User Agent\n\n\nZend\\Session\\Validator\\HttpUserAgent\n provides a validator to check the session\nagainst the originally stored \n$_SERVER['HTTP_USER_AGENT']\n variable. Validation\nwill fail in the event that this does not match and throws an exception in\n\nZend\\Session\\SessionManager\n after \nsession_start()\n has been called.\n\n\nBasic Usage\n\n\nuse Zend\\Session\\Validator\\HttpUserAgent;\nuse Zend\\Session\\SessionManager;\n\n$manager = new SessionManager();\n$manager->getValidatorChain()\n    ->attach('session.validate', [new HttpUserAgent(), 'isValid']);\n\n\n\nRemote Addr\n\n\nZend\\Session\\Validator\\RemoteAddr\n provides a validator to check the session\nagainst the originally stored \n$_SERVER['REMOTE_ADDR']\n variable. Validation\nwill fail in the event that this does not match and throws an exception in\n\nZend\\Session\\SessionManager\n after \nsession_start()\n has been called.\n\n\nBasic Usage\n\n\nuse Zend\\Session\\Validator\\RemoteAddr;\nuse Zend\\Session\\SessionManager;\n\n$manager = new SessionManager();\n$manager->getValidatorChain()\n    ->attach('session.validate', [new RemoteAddr(), 'isValid']);\n\n\n\nCustom Validators\n\n\nYou may want to provide your own custom validators to validate against other\nitems from storing a token and validating a token to other various techniques.\nTo create a custom validator you \nmust\n implement the validation interface\n\nZend\\Session\\Validator\\ValidatorInterface\n.",
            "title": "Session Validators"
        },
        {
            "location": "/validator/#session-validators",
            "text": "Session validators provide protections against session hijacking.",
            "title": "Session Validators"
        },
        {
            "location": "/validator/#http-user-agent",
            "text": "Zend\\Session\\Validator\\HttpUserAgent  provides a validator to check the session\nagainst the originally stored  $_SERVER['HTTP_USER_AGENT']  variable. Validation\nwill fail in the event that this does not match and throws an exception in Zend\\Session\\SessionManager  after  session_start()  has been called.",
            "title": "Http User Agent"
        },
        {
            "location": "/validator/#basic-usage",
            "text": "use Zend\\Session\\Validator\\HttpUserAgent;\nuse Zend\\Session\\SessionManager;\n\n$manager = new SessionManager();\n$manager->getValidatorChain()\n    ->attach('session.validate', [new HttpUserAgent(), 'isValid']);",
            "title": "Basic Usage"
        },
        {
            "location": "/validator/#remote-addr",
            "text": "Zend\\Session\\Validator\\RemoteAddr  provides a validator to check the session\nagainst the originally stored  $_SERVER['REMOTE_ADDR']  variable. Validation\nwill fail in the event that this does not match and throws an exception in Zend\\Session\\SessionManager  after  session_start()  has been called.",
            "title": "Remote Addr"
        },
        {
            "location": "/validator/#basic-usage_1",
            "text": "use Zend\\Session\\Validator\\RemoteAddr;\nuse Zend\\Session\\SessionManager;\n\n$manager = new SessionManager();\n$manager->getValidatorChain()\n    ->attach('session.validate', [new RemoteAddr(), 'isValid']);",
            "title": "Basic Usage"
        },
        {
            "location": "/validator/#custom-validators",
            "text": "You may want to provide your own custom validators to validate against other\nitems from storing a token and validating a token to other various techniques.\nTo create a custom validator you  must  implement the validation interface Zend\\Session\\Validator\\ValidatorInterface .",
            "title": "Custom Validators"
        }
    ]
}